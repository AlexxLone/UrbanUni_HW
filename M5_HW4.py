# Задача "История строительства":
# Для решения этой задачи будем пользоваться решением к предыдущей задаче "Перегрузка операторов".
# В классе House создайте атрибут houses_history = [], который будет хранить названия созданных объектов.
# Правильней вписывать здание в историю сразу при создании объекта, тем более можно удобно обращаться
# к атрибутам класса используя ссылку на сам класс - cls.
# Дополните метод __new__ так, чтобы:
# Название объекта добавлялось в список cls. houses_history.
# Название строения можно взять из args по индексу.
# Также переопределите метод __del__(self) в котором будет выводится строка:
# "<название> снесён, но он останется в истории"
# Создайте несколько объектов класса House и проверьте работу методов __del__ и __new__,
# а также значение атрибута houses_history.
import sys


class Building:
    _reg = []  # список указателей. использую для обхода экземпляров класса в цикле
    houses_history = []  # исторический журнал по ДЗ
    # перечень основных параметров строения:
    # "ЖК"/квартал/микрорайон, номер дома (может быть с литерой), номер строения, этажность, назначение
    b_main_param_key = ["community", 'house_number', 'building_number', 'storeys', 'function']

    def __new__(cls, *args, **kwargs):
        # формируем строку основных параметров для записи в исторический журнал
        # ("ЖК"/квартал/микрорайон, номер дома, номер строения).
        # Передаваемая запись может содержать только 2-а первых параметра.
        # Пришлось ввести доп. проверки на наличие строения, как такового, и на его наличие в адресе.
        if len(args) < 3:  # если поступила упрощенная форма записи, только квартал и номер дома
            cls.houses_history.append(f'{args[0]}, дом №{args[1]}.')
        else:
            cls.houses_history.append(
                f'{args[0]}, дом №{args[1]}{f", строение {args[2]}." if args[2] is not None else "."}')
        # obj = object.__new__(cls)  # так в ДЗ. прямое обращение к родительскому базовому классу obj
        obj = super().__new__(cls)  # так было в лекции. обращение к прокси-объекту. более верный вариант
        cls._reg.append(obj)
        return obj

    def __init__(self, *args, **kwargs):
        # ввод основных и дополнительных параметров строения в экземпляр класса:
        #  temp_dict = dict(zip(Building.b_main_param_key, args))
        #  temp_dict.update(kwargs)
        temp_dict = {**dict(zip(Building.b_main_param_key, args)), **kwargs}  # синтаксис 3.5.
        for key, values in temp_dict.items():
            setattr(self, key, values)

    def __del__(self):
        # формируем строку записи в исторический журнал но теперь по данным экземпляра класса.
        # подсказки pycharm  не работают в данном случае...
        # "community", 'house_number', 'building_number', 'storeys', 'function'
        record = (f'{self.community}, дом №{self.house_number}'
                  f'{f", строение {self.building_number}." if hasattr(self, "building_number") else "."}'
                  f' Снесен. Но навсегда останется в нашей памяти!')
        print(record)
        Building.houses_history.append(record)
        # print(sys.stderr)

    def _pre_del(self):
        Building._reg.remove(self)  # удаляем ссылку в списке указателей

    @classmethod
    def _print_history(cls):
        print(f'\033[34mИсторический журнал:\033[0m {cls.houses_history}')

    @classmethod
    def _print_all(cls):
        # вывод полного перечня созданных объектов класса и его аттрибутов:
        for instance in cls._reg:
            print(f'\n\033[31m{instance}:')
            # print(f'\n\033[31m{instance.__mro__}:\033[34m')
            for key, value in vars(instance).items():
                print(f'\t\033[34m{key}: \033[39m{value}')
        print('\033[0m')


# скучное наполнение параметрами для проверки:
# сначала по условиям ДЗ:
h1 = Building('ЖК Эльбрус', 10)
Building._print_history()  # pycharm ругается на доступ к защищенному методу класса
h2 = Building('ЖК Акация', 20)
Building._print_history()  # pycharm ругается на доступ к защищенному методу класса
h3 = Building('ЖК Матрёшки', 20)
Building._print_history()  # pycharm ругается на доступ к защищенному методу класса
# # Удаление объектов
print("Удаляем h1 и h2:")
Building._pre_del(h1)
# Building.__del__(h1) # вызов метода таким образом отрабатывает код внутри метода, но сам объект не удаляется.
del h1
Building._pre_del(h2)
# Building.__del__(h2)
del h2
Building._print_history()  # pycharm ругается на доступ к защищенному методу класса
input('Далее - доп. работа по разбору *args, **kwargs, просмотра полного списка экземпляров и прочее. \nPress "Enter"')

# далее - наполнение данными для проверки передачи *args b **kwargs
# формат основных параметров строения: "ЖК", номер дома (может быть как числом, так и строкой (с литерой)),
# номер строения, этажность, назначение
h4_param = ('ЖК "Парус"', 1, None, 24, "многоквартирный жилой дом")
# формат дополнительных параметров произволен
h4_add_param = {"подъездов": 5, "квартир": 460, "пассажирских лифтов на подъезд": 2, "грузовых лифтов на подъезд": 1}

h5_param = ('ЖК "Адмирал"', "2a", 1, 16, "многоквартирный жилой дом")
h5_add_param = {"подъездов": 2, "квартир": 64, "пассажирских лифтов на подъезд": 2, "грузовых лифтов на подъезд": 2,
                "спорт-залов": 2, "бассейнов": 1, "назначение верхнего этажа": "открытая веранда"}

h4 = Building(*h4_param, **h4_add_param)
print(Building.houses_history)
# print(Building.__mro__)

h5 = Building(*h5_param, **h5_add_param)
print(Building.houses_history)

Building._print_all()
Building._print_history()
# задержка перед удалением всех экземпляров при завершении программы:
# почему при выходе вызывается метод __del__ с удаленными ранее экземплярами???
print('\033[31m')
input('Завершение работы программы, удаление всех оставшихся экземпляров класса Building. \nPress "Enter"')
